# Simple command dispatcher

[![go-test](https://github.com/fljdin/dispatch/actions/workflows/go-test.yml/badge.svg)](https://github.com/fljdin/dispatch/actions/workflows/go-test.yml)
[![go-e2e](https://github.com/fljdin/dispatch/actions/workflows/go-e2e.yml/badge.svg)](https://github.com/fljdin/dispatch/actions/workflows/go-e2e.yml)

Orchestrates commands described in a YAML file with advanced features.

* Run multiple shell or psql commands in parallel
* Load and execute delimited commands or SQL statements from a file
* Run commands from the result of another command
* Make dependent a task from another

## Usage

```text
Usage:
  dispatch [options]

Options:
  -c, --config=FILE      configuration file
  -h, --help             display this help and exit
  -o, --output=FILE      redirect output to file
  -P, --procs=(+)PROCS   number of processes (default 1)
  -v, --verbose          verbose mode
      --version          show version

The number of processes is limited to the number of CPU cores available
locally by default. In a remote execution context, where the number of
processes must not rely on the local machine, the sign "+" can be used to
by-pass this limitation. For example, "dispatch -P +16" will spawn 16
processes regardless of the number of CPU cores available locally.
```

## Configuration

The configuration file is a YAML file that describes the tasks to be executed.

### Parallelism

```yaml
# "procs" declares number of processes
# option --procs takes precedence
procs: 1

# "remote" defines the execution context
# false (default): limit to the number of CPU cores available locally
# true: no limit is applied to the number of processes
remote: false
```

### Traces

```yaml
# redirect output to a file
output: /dev/stderr

# print debugging messages
verbose: false
```

### Commands

A basic unit of work is a task that executes a command. Each task is described
in an array of `tasks` with a unique identifier and a command to be executed.

```yaml
# run the following shell commands simultaneously
procs: 2
tasks:
  - id: 1
    command: echo foo
  - id: 2
    command: echo bar
```

A command type can be specified to use a supported execution context. Currently,
only `sh` (default) and `psql` are provided. The following example uses `psql`
to execute a SQL statement on a PostgreSQL with default environment variables.

```yaml
# execute SQL statement with psql
tasks:
  - id: 1
    type: psql
    name: run this statement
    command: SELECT user;
```

A task can be enriched with environment variables. This is the preferred way to
define connection parameters for a `psql` command.
See [Named environments](#named-environments) for more details.

```yaml
# use custom environment variables
tasks:
  - id: 1
    type: psql
    command: \conninfo
    variables:
      PGHOST: somehost
      PGDATABASE: somedb
      PGUSER: someuser
      PGPORT: someport
```

A task can depend on another task and will be executed only after the upstream
task has completed successfully. In a multi-process context, the next ready task
will be executed as soon as possible, regardless of the order of declaration.

```yaml
# make a task dependent from another
tasks:
  - id: 1
    command: echo foo
  - id: 2
    command: echo bar
    depends_on: [1]
```

### Loaders

A loader is an extended task that dispatch instructions from a command or a
file. These instructions will inherit the environment variables, command type,
and other properties from the loader task.

Use `file` as a replacement for `command` to read and dispatch instructions from
a file. Delimiter detection is provided by [Fragment] package and only `PgSQL`
and `Shell` languages are supported.

[Fragment]: https://github.com/fljdin/fragment

```yaml
# run queries from a file simultaneously
tasks:
  - id: 1
    type: psql
    name: dispatch queries from a file
    file: queries.sql
```

A more advanced loader relies on the result of a first-executed command to
generate a list of commands, which will be executed as regular tasks. Use the
special `loaded` and `from` keys to define the loader task as shown below.

```yaml
# run shell commands generated by a psql query
tasks:
  - id: 1
    type: sh
    name: execute reindexdb for all table except log
    loaded:
      from: psql
      command: |
        SELECT format('reindexdb -v -t %I;', tablename) FROM pg_tables
        WHERE schemaname = 'public' AND tablename NOT IN ('log')
      variables:
        PGDATABASE: mydb
```

### Named environments

Named environments are shared accross the configuration file and can be used to
define environment variables for tasks. Use the `env` key to attach environment
variables to a task.

The `variables` key takes precedence over the variables defined by the named
environment. A special environment named `default` is applied to all tasks by
default.

```yaml
environments:
  - name: custom
    variables:
      PGHOST: remote.example.com
      PGUSER: alice
  - name: default
    variables:
      PGDATABASE: postgres

tasks:
  - id: 1
    name: Use variables, custom env and default env scopes
    env: custom
    variables:
      PGAPPNAME: my_app
```

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## References

- [dispatcher_pg](https://github.com/marco44/dispatcher_pg) - Dispatch a bunch
  of queries over several sessions

- [Dagu](https://github.com/dagu-org/dagu) - Developer-friendly, minimalism
  Cron alternative, but with much more capabilities. It aims to solve greate
  problems.

- [Ansible](https://docs.ansible.com/ansible/) - Ansible is a radically simple
  IT automation platform that makes your applications and systems easier to
  deploy and maintain.
